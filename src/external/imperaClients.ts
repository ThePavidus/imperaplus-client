/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v10.6.6324.28497 (NJsonSchema v8.33.6323.36213) (http://NSwag.org)
// </auto-generated>
//----------------------


export class AccountClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;
    }

    exchange(grant_type: string, username: string, password: string, scope: string, refresh_token: string): Promise<LoginResponseModel> {
        let url_ = this.baseUrl + "/api/Account/token?";
        let content_ = "";
        if (grant_type !== undefined)
            content_ += "grant_type=" + encodeURIComponent("" + grant_type) + "&";

        if (username !== undefined)
            content_ += "username=" + encodeURIComponent("" + username) + "&";

        if (password !== undefined)
            content_ += "password=" + encodeURIComponent("" + password) + "&";

        if (scope !== undefined)
            content_ += "scope=" + encodeURIComponent("" + scope) + "&";

        if (refresh_token !== undefined)
            content_ += "refresh_token=" + encodeURIComponent("" + refresh_token) + "&";

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/x-www-form-urlencoded",
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processExchange(response);
        });
    }

    protected processExchange(response: Response): Promise<LoginResponseModel | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
                let result200: LoginResponseModel | null = null;
                result200 = responseText === "" ? null : <LoginResponseModel>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<LoginResponseModel | null>(<any>null);
    }

    /**
     * Checks if a username is available
     * @userName Username to check
     * @return True if username is available
     */
    getUserNameAvailable(userName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Account/UserNameAvailable?";
        if (userName === undefined)
            throw new Error("The parameter 'userName' must be defined.");
        else
            url_ += "userName=" + encodeURIComponent("" + userName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserNameAvailable(_response);
        });
    }

    protected processGetUserNameAvailable(response: Response): Promise<void> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
                return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Get user information
     */
    getUserInfo(): Promise<UserInfo | null> {
        let url_ = this.baseUrl + "/api/Account/UserInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserInfo(_response);
        });
    }

    protected processGetUserInfo(response: Response): Promise<UserInfo | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
                let result200: UserInfo | null = null;
                result200 = responseText === "" ? null : <UserInfo>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<UserInfo | null>(<any>null);
    }

    /**
     * Get user information for an external user (i.e., just logged in using an external provider)
     */
    getExternalUserInfo(): Promise<UserInfo | null> {
        let url_ = this.baseUrl + "/api/Account/ExternalUserInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetExternalUserInfo(_response);
        });
    }

    protected processGetExternalUserInfo(response: Response): Promise<UserInfo | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
                let result200: UserInfo | null = null;
                result200 = responseText === "" ? null : <UserInfo>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<UserInfo | null>(<any>null);
    }

    logout(): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/Account/Logout";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogout(_response);
        });
    }

    protected processLogout(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }

    getManageInfo(returnUrl: string, generateState: boolean): Promise<ManageInfoViewModel | null> {
        let url_ = this.baseUrl + "/api/Account/ManageInfo?";
        if (returnUrl === undefined)
            throw new Error("The parameter 'returnUrl' must be defined.");
        else
            url_ += "returnUrl=" + encodeURIComponent("" + returnUrl) + "&";
        if (generateState === null)
            throw new Error("The parameter 'generateState' cannot be null.");
        else if (generateState !== undefined)
            url_ += "generateState=" + encodeURIComponent("" + generateState) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetManageInfo(_response);
        });
    }

    protected processGetManageInfo(response: Response): Promise<ManageInfoViewModel | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
                let result200: ManageInfoViewModel | null = null;
                result200 = responseText === "" ? null : <ManageInfoViewModel>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<ManageInfoViewModel | null>(<any>null);
    }

    changePassword(model: ChangePasswordBindingModel): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/Account/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangePassword(_response);
        });
    }

    protected processChangePassword(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }

    setPassword(model: SetPasswordBindingModel): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/Account/SetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetPassword(_response);
        });
    }

    protected processSetPassword(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }

    removeLogin(model: RemoveLoginBindingModel): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/Account/RemoveLogin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveLogin(_response);
        });
    }

    protected processRemoveLogin(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }

    getExternalLogins(): Promise<ExternalLoginViewModel[] | null> {
        let url_ = this.baseUrl + "/api/Account/ExternalLogins";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetExternalLogins(_response);
        });
    }

    protected processGetExternalLogins(response: Response): Promise<ExternalLoginViewModel[] | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
                let result200: ExternalLoginViewModel[] | null = null;
                result200 = responseText === "" ? null : <ExternalLoginViewModel[]>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<ExternalLoginViewModel[] | null>(<any>null);
    }

    register(model: RegisterBindingModel): Promise<void> {
        let url_ = this.baseUrl + "/api/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegister(_response);
        });
    }

    protected processRegister(response: Response): Promise<void> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
                return;
            });
        } else if (status === 400) {
            return response.text().then((responseText) => {
                let result400: ErrorResponse | null = null;
                result400 = responseText === "" ? null : <ErrorResponse>JSON.parse(responseText, this.jsonParseReviver);
                return throwException("A server error occurred.", status, responseText, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Resend the email confirmation account to the given user account
     */
    resendConfirmationCode(model: ResendConfirmationModel): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/Account/ResendConfirmation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResendConfirmationCode(_response);
        });
    }

    protected processResendConfirmationCode(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }

    /**
     * Confirm user account using code provided in mail
     * @model Model containing id and code
     * @return Success if successfully activated
     */
    confirmEmail(model: ConfirmationModel): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/Account/ConfirmEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processConfirmEmail(_response);
        });
    }

    protected processConfirmEmail(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }

    /**
     * Request password reset link
     */
    forgotPassword(model: ForgotPasswordViewModel): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/Account/ForgotPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processForgotPassword(_response);
        });
    }

    protected processForgotPassword(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }

    /**
     * Reset password confirmation
     */
    resetPassword(model: ResetPasswordViewModel): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/Account/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResetPassword(_response);
        });
    }

    protected processResetPassword(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }

    /**
     * Create user accout for an external login
     */
    registerExternal(model: RegisterExternalBindingModel): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/Account/RegisterExternal";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegisterExternal(_response);
        });
    }

    protected processRegisterExternal(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }
}

export class GameClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;
    }

    /**
     * Get a list of open games, excluding games by the current player
     * @return List of games
     */
    getAll(): Promise<GameSummary[] | null> {
        let url_ = this.baseUrl + "/api/games/open";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<GameSummary[] | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
                let result200: GameSummary[] | null = null;
                result200 = responseText === "" ? null : <GameSummary[]>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<GameSummary[] | null>(<any>null);
    }

    /**
     * Get a list of the games for the current player
     * @return List of games for the current user
     */
    getMy(): Promise<GameSummary[] | null> {
        let url_ = this.baseUrl + "/api/games/my";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMy(_response);
        });
    }

    protected processGetMy(response: Response): Promise<GameSummary[] | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
                let result200: GameSummary[] | null = null;
                result200 = responseText === "" ? null : <GameSummary[]>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<GameSummary[] | null>(<any>null);
    }

    /**
     * Get list of games where it's the current player's team
     * @return List of games where it's the current user's team
     */
    getMyTurn(): Promise<GameSummary[] | null> {
        let url_ = this.baseUrl + "/api/games/myturn";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMyTurn(_response);
        });
    }

    protected processGetMyTurn(response: Response): Promise<GameSummary[] | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
                let result200: GameSummary[] | null = null;
                result200 = responseText === "" ? null : <GameSummary[]>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<GameSummary[] | null>(<any>null);
    }

    /**
     * Create a new game
     * @creationOptions Creation options
     * @return Summary of newly created game
     */
    post(creationOptions: GameCreationOptions): Promise<GameSummary | null> {
        let url_ = this.baseUrl + "/api/games";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(creationOptions);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<GameSummary | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
                let result200: GameSummary | null = null;
                result200 = responseText === "" ? null : <GameSummary>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<GameSummary | null>(<any>null);
    }

    /**
     * Get detailed information about a single game
     * @gameId Id of the requested game
     * @return Information about the requested game
     */
    get(gameId: number): Promise<Game | null> {
        let url_ = this.baseUrl + "/api/games/{gameId}";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<Game | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
                let result200: Game | null = null;
                result200 = responseText === "" ? null : <Game>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Game | null>(<any>null);
    }

    /**
     * Cancel/delete the requested game, if possible.
     * @gameId Id of the game to delete
     * @return Status
     */
    delete(gameId: number): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/games/{gameId}";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }

    /**
     * Get messages for a single game
     * @gameId Id of the requested game
     * @isPublic Value indicating whether to return only public messages, default is true
     * @return Messages posted in the requested game
     */
    getMessages(gameId: number, isPublic: boolean): Promise<GameChatMessage[] | null> {
        let url_ = this.baseUrl + "/api/games/{gameId}/messages?";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId));
        if (isPublic === null)
            throw new Error("The parameter 'isPublic' cannot be null.");
        else if (isPublic !== undefined)
            url_ += "isPublic=" + encodeURIComponent("" + isPublic) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMessages(_response);
        });
    }

    protected processGetMessages(response: Response): Promise<GameChatMessage[] | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
                let result200: GameChatMessage[] | null = null;
                result200 = responseText === "" ? null : <GameChatMessage[]>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<GameChatMessage[] | null>(<any>null);
    }

    /**
     * Join the given game
     * @gameId Id of game to join
     */
    postJoin(gameId: number): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/games/{gameId}/join";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostJoin(_response);
        });
    }

    protected processPostJoin(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }

    /**
     * Leave the given game, only possible if game hasn't started yet, and current player
is not the creator.
     * @gameId Id of game to leave
     */
    postLeave(gameId: number): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/games/{gameId}/leave";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostLeave(_response);
        });
    }

    protected processPostLeave(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }

    /**
     * Surrender in the given game, only possible if current player
and game are still active.
     * @gameId Id of game to surrender in
     */
    postSurrender(gameId: number): Promise<GameSummary | null> {
        let url_ = this.baseUrl + "/api/games/{gameId}/surrender";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostSurrender(_response);
        });
    }

    protected processPostSurrender(response: Response): Promise<GameSummary | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
                let result200: GameSummary | null = null;
                result200 = responseText === "" ? null : <GameSummary>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<GameSummary | null>(<any>null);
    }

    /**
     * Hides the given game for the current player
     * @gameId Id of game to hide
     */
    patchHide(gameId: number): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/games/{gameId}/hide";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPatchHide(_response);
        });
    }

    protected processPatchHide(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }

    /**
     * Hide all games which can be hidden for the current player
     */
    patchHideAll(): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/games/hide";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPatchHideAll(_response);
        });
    }

    protected processPatchHideAll(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }
}

export class HistoryClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;
    }

    /**
     * Gets the specified turn including the actions and current state of the map
     */
    getTurn(gameId: number, turnId: number): Promise<HistoryTurn | null> {
        let url_ = this.baseUrl + "/api/games/{gameId}/history/{turnId}";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId));
        if (turnId === undefined || turnId === null)
            throw new Error("The parameter 'turnId' must be defined.");
        url_ = url_.replace("{turnId}", encodeURIComponent("" + turnId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTurn(_response);
        });
    }

    protected processGetTurn(response: Response): Promise<HistoryTurn | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
                let result200: HistoryTurn | null = null;
                result200 = responseText === "" ? null : <HistoryTurn>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<HistoryTurn | null>(<any>null);
    }
}

export class LadderClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;
    }

    /**
     * Returns active ladders
     * @return List of ladders
     */
    getAll(): Promise<LadderSummary[] | null> {
        let url_ = this.baseUrl + "/api/ladder";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<LadderSummary[] | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
                let result200: LadderSummary[] | null = null;
                result200 = responseText === "" ? null : <LadderSummary[]>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<LadderSummary[] | null>(<any>null);
    }

    /**
     * Gets ladder identified by given id
     * @ladderId Id of ladder
     */
    get(ladderId: string): Promise<Ladder | null> {
        let url_ = this.baseUrl + "/api/ladder/{ladderId}";
        if (ladderId === undefined || ladderId === null)
            throw new Error("The parameter 'ladderId' must be defined.");
        url_ = url_.replace("{ladderId}", encodeURIComponent("" + ladderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<Ladder | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
                let result200: Ladder | null = null;
                result200 = responseText === "" ? null : <Ladder>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Ladder | null>(<any>null);
    }

    /**
     * Queue up for a new game in the given ladder
     * @ladderId Ladder id
     * @return Status
     */
    postJoin(ladderId: string): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/ladder/{ladderId}/queue";
        if (ladderId === undefined || ladderId === null)
            throw new Error("The parameter 'ladderId' must be defined.");
        url_ = url_.replace("{ladderId}", encodeURIComponent("" + ladderId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostJoin(_response);
        });
    }

    protected processPostJoin(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }

    /**
     * Gets ladder standings
     * @ladderId Id of ladder
     * @start Items to skip before returning
     * @count Count of standings to return
     */
    getStandings(ladderId: string, start: number, count: number): Promise<LadderStanding[] | null> {
        let url_ = this.baseUrl + "/api/ladder/{ladderId}/standings?";
        if (ladderId === undefined || ladderId === null)
            throw new Error("The parameter 'ladderId' must be defined.");
        url_ = url_.replace("{ladderId}", encodeURIComponent("" + ladderId));
        if (start === null)
            throw new Error("The parameter 'start' cannot be null.");
        else if (start !== undefined)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetStandings(_response);
        });
    }

    protected processGetStandings(response: Response): Promise<LadderStanding[] | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
                let result200: LadderStanding[] | null = null;
                result200 = responseText === "" ? null : <LadderStanding[]>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<LadderStanding[] | null>(<any>null);
    }
}

export class MapClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;
    }

    getAllSummary(): Promise<MapTemplateDescriptor[] | null> {
        let url_ = this.baseUrl + "/api/map";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllSummary(_response);
        });
    }

    protected processGetAllSummary(response: Response): Promise<MapTemplateDescriptor[] | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
                let result200: MapTemplateDescriptor[] | null = null;
                result200 = responseText === "" ? null : <MapTemplateDescriptor[]>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<MapTemplateDescriptor[] | null>(<any>null);
    }

    /**
     * Get map template identified by name
     */
    getMapTemplate(name: string): Promise<MapTemplate | null> {
        let url_ = this.baseUrl + "/api/map/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMapTemplate(_response);
        });
    }

    protected processGetMapTemplate(response: Response): Promise<MapTemplate | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
                let result200: MapTemplate | null = null;
                result200 = responseText === "" ? null : <MapTemplate>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<MapTemplate | null>(<any>null);
    }
}

export class MessageClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;
    }

    getAll(messageFolder: MessageFolder): Promise<Message[] | null> {
        let url_ = this.baseUrl + "/api/messages/folder/{messageFolder}";
        if (messageFolder === undefined || messageFolder === null)
            throw new Error("The parameter 'messageFolder' must be defined.");
        url_ = url_.replace("{messageFolder}", encodeURIComponent("" + messageFolder));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<Message[] | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
                let result200: Message[] | null = null;
                result200 = responseText === "" ? null : <Message[]>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Message[] | null>(<any>null);
    }

    get(messageId: string): Promise<Message | null> {
        let url_ = this.baseUrl + "/api/messages/{messageId}";
        if (messageId === undefined || messageId === null)
            throw new Error("The parameter 'messageId' must be defined.");
        url_ = url_.replace("{messageId}", encodeURIComponent("" + messageId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<Message | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
                let result200: Message | null = null;
                result200 = responseText === "" ? null : <Message>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Message | null>(<any>null);
    }

    patchMarkRead(messageId: string): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/messages/{messageId}";
        if (messageId === undefined || messageId === null)
            throw new Error("The parameter 'messageId' must be defined.");
        url_ = url_.replace("{messageId}", encodeURIComponent("" + messageId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPatchMarkRead(_response);
        });
    }

    protected processPatchMarkRead(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }

    delete(messageId: string): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/messages/{messageId}";
        if (messageId === undefined || messageId === null)
            throw new Error("The parameter 'messageId' must be defined.");
        url_ = url_.replace("{messageId}", encodeURIComponent("" + messageId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }

    getFolderInformation(): Promise<FolderInformation[] | null> {
        let url_ = this.baseUrl + "/api/messages/folders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFolderInformation(_response);
        });
    }

    protected processGetFolderInformation(response: Response): Promise<FolderInformation[] | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
                let result200: FolderInformation[] | null = null;
                result200 = responseText === "" ? null : <FolderInformation[]>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<FolderInformation[] | null>(<any>null);
    }

    postSend(message: SendMessage): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/messages";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(message);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostSend(_response);
        });
    }

    protected processPostSend(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }
}

export class NewsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;
    }

    /**
     * Returns the last 10 news items for all languages
     * @return List of news items
     */
    getAll(): Promise<NewsItem[] | null> {
        let url_ = this.baseUrl + "/api/news";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<NewsItem[] | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
                let result200: NewsItem[] | null = null;
                result200 = responseText === "" ? null : <NewsItem[]>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<NewsItem[] | null>(<any>null);
    }
}

export class NotificationClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;
    }

    /**
     * Get notification summary for current user
     */
    getSummary(): Promise<NotificationSummary | null> {
        let url_ = this.baseUrl + "/api/notifications/summary";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSummary(_response);
        });
    }

    protected processGetSummary(response: Response): Promise<NotificationSummary | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
                let result200: NotificationSummary | null = null;
                result200 = responseText === "" ? null : <NotificationSummary>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<NotificationSummary | null>(<any>null);
    }
}

export class PlayClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;
    }

    /**
     * Place units to countries.
     * @gameId Id of the game
     * @placeUnitsOptions List of country/unit count pairs
     * @return GameActionResult of action
     */
    postPlace(gameId: number, placeUnitsOptions: PlaceUnitsOptions[]): Promise<GameActionResult | null> {
        let url_ = this.baseUrl + "/api/games/{gameId}/play/place";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(placeUnitsOptions);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostPlace(_response);
        });
    }

    protected processPostPlace(response: Response): Promise<GameActionResult | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
                let result200: GameActionResult | null = null;
                result200 = responseText === "" ? null : <GameActionResult>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<GameActionResult | null>(<any>null);
    }

    /**
     * Exchange cards for the current player. Which cards to exchange is automatically chosen to gain the most bonus for the player.
     * @gameId Id of the game
     * @return GameActionResult of action
     */
    postExchange(gameId: number): Promise<GameActionResult | null> {
        let url_ = this.baseUrl + "/api/games/{gameId}/play/exchange";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostExchange(_response);
        });
    }

    protected processPostExchange(response: Response): Promise<GameActionResult | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
                let result200: GameActionResult | null = null;
                result200 = responseText === "" ? null : <GameActionResult>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<GameActionResult | null>(<any>null);
    }

    /**
     * Attack from one to another country.
     * @gameId Id of the game
     * @options Options for the command
     * @return GameActionResult of action
     */
    postAttack(gameId: number, options: AttackOptions): Promise<GameActionResult | null> {
        let url_ = this.baseUrl + "/api/games/{gameId}/play/attack";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(options);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostAttack(_response);
        });
    }

    protected processPostAttack(response: Response): Promise<GameActionResult | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
                let result200: GameActionResult | null = null;
                result200 = responseText === "" ? null : <GameActionResult>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<GameActionResult | null>(<any>null);
    }

    /**
     * Switch to moving.
     * @gameId Id of the game
     * @return GameActionResult of action
     */
    postEndAttack(gameId: number): Promise<GameActionResult | null> {
        let url_ = this.baseUrl + "/api/games/{gameId}/play/endattack";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostEndAttack(_response);
        });
    }

    protected processPostEndAttack(response: Response): Promise<GameActionResult | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
                let result200: GameActionResult | null = null;
                result200 = responseText === "" ? null : <GameActionResult>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<GameActionResult | null>(<any>null);
    }

    /**
     * Move units between countries. Only allowed after placing. Cancels any attacks that the player had left before. Attacking is not
possible anymore after moving.
     * @gameId Id of the game
     * @options Options for the command
     * @return GameActionResult of action
     */
    postMove(gameId: number, options: MoveOptions): Promise<GameActionResult | null> {
        let url_ = this.baseUrl + "/api/games/{gameId}/play/move";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(options);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostMove(_response);
        });
    }

    protected processPostMove(response: Response): Promise<GameActionResult | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
                let result200: GameActionResult | null = null;
                result200 = responseText === "" ? null : <GameActionResult>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<GameActionResult | null>(<any>null);
    }

    /**
     * End the current turn
     * @gameId Id of the game
     * @return GameActionResult of action
     */
    postEndTurn(gameId: number): Promise<Game | null> {
        let url_ = this.baseUrl + "/api/games/{gameId}/play/endturn";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostEndTurn(_response);
        });
    }

    protected processPostEndTurn(response: Response): Promise<Game | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
                let result200: Game | null = null;
                result200 = responseText === "" ? null : <Game>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Game | null>(<any>null);
    }
}

export class TournamentClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;
    }

    /**
     * Returns tournaments
     * @return List of tournaments
     */
    getAll(): Promise<TournamentSummary[] | null> {
        let url_ = this.baseUrl + "/api/tournaments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<TournamentSummary[] | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
                let result200: TournamentSummary[] | null = null;
                result200 = responseText === "" ? null : <TournamentSummary[]>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<TournamentSummary[] | null>(<any>null);
    }

    /**
     * Get tournament identified by Id
     * @tournamentId Id of tournament
     */
    getById(tournamentId: string): Promise<Tournament | null> {
        let url_ = this.baseUrl + "/api/tournaments/{tournamentId}";
        if (tournamentId === undefined || tournamentId === null)
            throw new Error("The parameter 'tournamentId' must be defined.");
        url_ = url_.replace("{tournamentId}", encodeURIComponent("" + tournamentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: Response): Promise<Tournament | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
                let result200: Tournament | null = null;
                result200 = responseText === "" ? null : <Tournament>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Tournament | null>(<any>null);
    }

    /**
     * Join tournament
     * @tournamentId Id of tournament
     */
    postJoin(tournamentId: string): Promise<TournamentTeam | null> {
        let url_ = this.baseUrl + "/api/tournaments/{tournamentId}";
        if (tournamentId === undefined || tournamentId === null)
            throw new Error("The parameter 'tournamentId' must be defined.");
        url_ = url_.replace("{tournamentId}", encodeURIComponent("" + tournamentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostJoin(_response);
        });
    }

    protected processPostJoin(response: Response): Promise<TournamentTeam | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
                let result200: TournamentTeam | null = null;
                result200 = responseText === "" ? null : <TournamentTeam>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<TournamentTeam | null>(<any>null);
    }

    /**
     * Get teams for tournament
     * @tournamentId Id of tournament
     */
    getTeams(tournamentId: string): Promise<TournamentTeam[] | null> {
        let url_ = this.baseUrl + "/api/tournaments/{tournamentId}/teams";
        if (tournamentId === undefined || tournamentId === null)
            throw new Error("The parameter 'tournamentId' must be defined.");
        url_ = url_.replace("{tournamentId}", encodeURIComponent("" + tournamentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTeams(_response);
        });
    }

    protected processGetTeams(response: Response): Promise<TournamentTeam[] | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
                let result200: TournamentTeam[] | null = null;
                result200 = responseText === "" ? null : <TournamentTeam[]>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<TournamentTeam[] | null>(<any>null);
    }

    /**
     * Create new team for a tournament
     * @tournamentId Id of tournament
     * @name Name of team
     * @password Optional password for team
     * @return Summary of newly created team
     */
    postCreateTeam(tournamentId: string, name: string, password: string): Promise<TournamentTeam | null> {
        let url_ = this.baseUrl + "/api/tournaments/{tournamentId}/teams?";
        if (tournamentId === undefined || tournamentId === null)
            throw new Error("The parameter 'tournamentId' must be defined.");
        url_ = url_.replace("{tournamentId}", encodeURIComponent("" + tournamentId));
        if (name === undefined)
            throw new Error("The parameter 'name' must be defined.");
        else
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (password !== undefined)
            url_ += "password=" + encodeURIComponent("" + password) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostCreateTeam(_response);
        });
    }

    protected processPostCreateTeam(response: Response): Promise<TournamentTeam | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
                let result200: TournamentTeam | null = null;
                result200 = responseText === "" ? null : <TournamentTeam>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<TournamentTeam | null>(<any>null);
    }

    /**
     * Join existing team
     * @tournamentId Id of tournament
     * @teamId Id of team
     * @password Optional password for team to join
     */
    postJoinTeam(tournamentId: string, teamId: string, password: string): Promise<TournamentTeam | null> {
        let url_ = this.baseUrl + "/api/tournaments/{tournamentId}/teams/{teamId}?";
        if (tournamentId === undefined || tournamentId === null)
            throw new Error("The parameter 'tournamentId' must be defined.");
        url_ = url_.replace("{tournamentId}", encodeURIComponent("" + tournamentId));
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId));
        if (password !== undefined)
            url_ += "password=" + encodeURIComponent("" + password) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostJoinTeam(_response);
        });
    }

    protected processPostJoinTeam(response: Response): Promise<TournamentTeam | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
                let result200: TournamentTeam | null = null;
                result200 = responseText === "" ? null : <TournamentTeam>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<TournamentTeam | null>(<any>null);
    }

    /**
     * Delete a team. Only allowed if user created it
     * @tournamentId Id of tournament
     * @teamId Id of team to delete
     */
    deleteTeam(tournamentId: string, teamId: string): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/tournaments/{tournamentId}/teams/{teamId}";
        if (tournamentId === undefined || tournamentId === null)
            throw new Error("The parameter 'tournamentId' must be defined.");
        url_ = url_.replace("{tournamentId}", encodeURIComponent("" + tournamentId));
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteTeam(_response);
        });
    }

    protected processDeleteTeam(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }

    /**
     * Leave a team and tournament
     * @tournamentId Id of tournament
     */
    leaveTournament(tournamentId: string): Promise<Blob | null> {
        let url_ = this.baseUrl + "/api/tournaments/{tournamentId}/teams/me";
        if (tournamentId === undefined || tournamentId === null)
            throw new Error("The parameter 'tournamentId' must be defined.");
        url_ = url_.replace("{tournamentId}", encodeURIComponent("" + tournamentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLeaveTournament(_response);
        });
    }

    protected processLeaveTournament(response: Response): Promise<Blob | null> {
        const status = response.status;
        if (status === 200) {
            return response.blob();
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<Blob | null>(<any>null);
    }
}

export class UserClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;
    }

    /**
     * Find users starting with the given query
     * @query Query to search for
     */
    findUsers(query: string): Promise<UserReference[] | null> {
        let url_ = this.baseUrl + "/api/users/find/{query}";
        if (query === undefined || query === null)
            throw new Error("The parameter 'query' must be defined.");
        url_ = url_.replace("{query}", encodeURIComponent("" + query));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8",
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindUsers(_response);
        });
    }

    protected processFindUsers(response: Response): Promise<UserReference[] | null> {
        const status = response.status;
        if (status === 200) {
            return response.text().then((responseText) => {
                let result200: UserReference[] | null = null;
                result200 = responseText === "" ? null : <UserReference[]>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((responseText) => {
                return throwException("An unexpected server error occurred.", status, responseText);
            });
        }
        return Promise.resolve<UserReference[] | null>(<any>null);
    }
}

export interface LoginResponseModel {
    access_token?: string | undefined;
    refresh_token?: string | undefined;
}

export interface UserInfo {
    userId?: string | undefined;
    userName?: string | undefined;
    hasRegistered: boolean;
    loginProvider?: string | undefined;
    language?: string | undefined;
    roles?: string[] | undefined;
}

export interface ManageInfoViewModel {
    localLoginProvider?: string | undefined;
    userName?: string | undefined;
    logins?: UserLoginInfoViewModel[] | undefined;
    externalLoginProviders?: ExternalLoginViewModel[] | undefined;
}

export interface UserLoginInfoViewModel {
    loginProvider?: string | undefined;
    providerKey?: string | undefined;
}

export interface ExternalLoginViewModel {
    name?: string | undefined;
    authenticationScheme?: string | undefined;
}

export interface ChangePasswordBindingModel {
    oldPassword: string;
    newPassword: string;
    confirmPassword?: string | undefined;
}

export interface SetPasswordBindingModel {
    newPassword: string;
    confirmPassword?: string | undefined;
}

export interface RemoveLoginBindingModel {
    loginProvider: string;
    providerKey: string;
}

export interface RegisterBindingModel {
    userName: string;
    password: string;
    confirmPassword?: string | undefined;
    email: string;
    language: string;
    callbackUrl: string;
}

export interface ErrorResponse {
    error?: string | undefined;
    error_Description?: string | undefined;
    parameter_Errors?: { [key: string]: string[]; } | undefined;
}

export interface ResendConfirmationModel {
    callbackUrl: string;
    userName: string;
    password: string;
    language: string;
}

export interface ConfirmationModel {
    userId: string;
    code: string;
}

export interface ForgotPasswordViewModel {
    callbackUrl: string;
    userName: string;
    email: string;
    language: string;
}

export interface ResetPasswordViewModel {
    userId: string;
    password: string;
    confirmPassword?: string | undefined;
    code: string;
}

export interface RegisterExternalBindingModel {
    userName: string;
    email: string;
}

export interface GameSummary {
    id: number;
    type: GameType;
    name?: string | undefined;
    ladderId?: string | undefined;
    ladderName?: string | undefined;
    options?: GameOptions | undefined;
    createdByUserId?: string | undefined;
    createdByName?: string | undefined;
    startedAt?: Date | undefined;
    lastActionAt: Date;
    timeoutSecondsLeft: number;
    mapTemplate?: string | undefined;
    state: GameState;
    currentPlayer?: PlayerSummary | undefined;
    teams?: TeamSummary[] | undefined;
}

export enum GameType {
    Fun = <any>"Fun",
    Ranking = <any>"Ranking",
    Tournament = <any>"Tournament",
}

export interface GameOptions {
    numberOfPlayersPerTeam: number;
    numberOfTeams: number;
    minUnitsPerCountry: number;
    newUnitsPerTurn: number;
    attacksPerTurn: number;
    movesPerTurn: number;
    initialCountryUnits: number;
    mapDistribution: MapDistribution;
    timeoutInSeconds: number;
    maximumTimeoutsPerPlayer: number;
    maximumNumberOfCards: number;
    victoryConditions: VictoryConditionType[];
    visibilityModifier: VisibilityModifierType[];
}

export enum MapDistribution {
    Default = <any>"Default",
    Malibu = <any>"Malibu",
    TeamCluster = <any>"TeamCluster",
}

export enum VictoryConditionType {
    Survival = <any>"Survival",
    ControlContinent = <any>"ControlContinent",
}

export enum VisibilityModifierType {
    None = <any>"None",
    Fog = <any>"Fog",
}

export enum GameState {
    None = <any>"None",
    Open = <any>"Open",
    Active = <any>"Active",
    Ended = <any>"Ended",
}

export interface PlayerSummary {
    id: string;
    userId?: string | undefined;
    name?: string | undefined;
    state: PlayerState;
    outcome: PlayerOutcome;
    teamId: string;
    playOrder: number;
    timeouts: number;
}

export enum PlayerState {
    None = <any>"None",
    Active = <any>"Active",
    InActive = <any>"InActive",
}

export enum PlayerOutcome {
    None = <any>"None",
    Won = <any>"Won",
    Defeated = <any>"Defeated",
    Surrendered = <any>"Surrendered",
    Timeout = <any>"Timeout",
}

export interface TeamSummary {
    id: string;
    playOrder: number;
    players?: PlayerSummary[] | undefined;
}

export interface GameCreationOptions extends GameOptions {
    name: string;
    addBot: boolean;
    mapTemplate: string;
}

export interface Game {
    id: number;
    type: GameType;
    name?: string | undefined;
    mapTemplate?: string | undefined;
    teams?: Team[] | undefined;
    state: GameState;
    playState: PlayState;
    currentPlayer?: PlayerSummary | undefined;
    map?: Map | undefined;
    options?: GameOptions | undefined;
    lastModifiedAt: Date;
    timeoutSecondsLeft: number;
    turnCounter: number;
    unitsToPlace: number;
    attacksInCurrentTurn: number;
    movesInCurrentTurn: number;
}

export interface Team {
    id: string;
    playOrder: number;
    players?: Player[] | undefined;
}

export interface Player extends PlayerSummary {
    cards?: BonusCard[] | undefined;
    placedInitialUnits: boolean;
    numberOfUnits: number;
    numberOfCountries: number;
}

export enum BonusCard {
    A = <any>"A",
    B = <any>"B",
    C = <any>"C",
}

export enum PlayState {
    None = <any>"None",
    PlaceUnits = <any>"PlaceUnits",
    Attack = <any>"Attack",
    Move = <any>"Move",
    Done = <any>"Done",
}

export interface Map {
    countries?: Country[] | undefined;
}

export interface Country {
    identifier?: string | undefined;
    playerId: string;
    teamId: string;
    units: number;
}

export interface GameChatMessage {
    id: number;
    gameId: number;
    user?: UserReference | undefined;
    teamId: string;
    dateTime: Date;
    text?: string | undefined;
}

export interface UserReference {
    id?: string | undefined;
    name?: string | undefined;
}

export interface HistoryTurn {
    gameId: number;
    turnId: number;
    actions?: HistoryEntry[] | undefined;
    game?: Game | undefined;
}

export interface HistoryEntry {
    id: number;
    turnNo: number;
    dateTime: Date;
    actorId: string;
    otherPlayerId?: string | undefined;
    action: HistoryAction;
    originIdentifier?: string | undefined;
    destinationIdentifier?: string | undefined;
    units?: number | undefined;
    unitsLost?: number | undefined;
    unitsLostOther?: number | undefined;
    result?: boolean | undefined;
}

export enum HistoryAction {
    None = <any>"None",
    StartGame = <any>"StartGame",
    EndGame = <any>"EndGame",
    PlaceUnits = <any>"PlaceUnits",
    Attack = <any>"Attack",
    Move = <any>"Move",
    ExchangeCards = <any>"ExchangeCards",
    PlayerLost = <any>"PlayerLost",
    PlayerWon = <any>"PlayerWon",
    PlayerTimeout = <any>"PlayerTimeout",
    OwnerChange = <any>"OwnerChange",
    EndTurn = <any>"EndTurn",
    PlayerSurrendered = <any>"PlayerSurrendered",
}

export interface LadderSummary {
    id: string;
    name?: string | undefined;
    options?: GameOptions | undefined;
    standing?: LadderStanding | undefined;
    isQueued: boolean;
    queueCount: number;
    mapTemplates: string[];
}

export interface LadderStanding {
    userId?: string | undefined;
    userName?: string | undefined;
    position: number;
    gamesPlayed: number;
    gamesWon: number;
    gamesLost: number;
    rating: number;
    lastGame: Date;
}

export interface Ladder extends LadderSummary {
    standings?: LadderStanding[] | undefined;
    isActive: boolean;
}

export interface MapTemplateDescriptor {
    name?: string | undefined;
}

export interface MapTemplate {
    name?: string | undefined;
    image?: string | undefined;
    countries?: CountryTemplate[] | undefined;
    connections?: Connection[] | undefined;
    continents?: Continent[] | undefined;
}

export interface CountryTemplate {
    identifier?: string | undefined;
    name?: string | undefined;
    x: number;
    y: number;
}

export interface Connection {
    origin?: string | undefined;
    destination?: string | undefined;
}

export interface Continent {
    id: number;
    name?: string | undefined;
    bonus: number;
    countries?: string[] | undefined;
}

export enum MessageFolder {
    None = <any>"None",
    Inbox = <any>"Inbox",
    Sent = <any>"Sent",
}

export interface SendMessage {
    to: UserReference;
    subject?: string | undefined;
    text?: string | undefined;
}

export interface Message extends SendMessage {
    id: string;
    from?: UserReference | undefined;
    folder: MessageFolder;
    sentAt: Date;
    isRead: boolean;
}

export interface FolderInformation {
    folder: MessageFolder;
    count: number;
    unreadCount: number;
}

export interface NewsItem {
    dateTime: Date;
    postedBy?: string | undefined;
    content?: NewsContent[] | undefined;
}

export interface NewsContent {
    language?: string | undefined;
    title?: string | undefined;
    text?: string | undefined;
}

export interface NotificationSummary {
    numberOfGames: number;
    numberOfMessages: number;
}

export interface PlaceUnitsOptions {
    countryIdentifier: string;
    numberOfUnits: number;
}

export interface GameActionResult {
    id: number;
    teams?: Team[] | undefined;
    state: GameState;
    playState: PlayState;
    countryUpdates?: Country[] | undefined;
    actionResult: ActionResult;
    unitsToPlace: number;
    attacksInCurrentTurn: number;
    movesInCurrentTurn: number;
    cards?: BonusCard[] | undefined;
    currentPlayer?: Player | undefined;
}

export enum ActionResult {
    None = <any>"None",
    Successful = <any>"Successful",
    NotSuccessful = <any>"NotSuccessful",
}

export interface AttackOptions {
    originCountryIdentifier: string;
    destinationCountryIdentifier: string;
    numberOfUnits: number;
}

export interface MoveOptions {
    originCountryIdentifier: string;
    destinationCountryIdentifier: string;
    numberOfUnits: number;
}

export interface TournamentSummary {
    id: string;
    name: string;
    state: TournamentState;
    options?: GameOptions | undefined;
    numberOfTeams: number;
    numberOfGroupGames: number;
    numberOfKnockoutGames: number;
    numberOfFinalGames: number;
    startOfRegistration: Date;
    startOfTournament: Date;
    endOfTournament: Date;
    completion: number;
}

export enum TournamentState {
    Open = <any>"Open",
    Groups = <any>"Groups",
    Knockout = <any>"Knockout",
    Closed = <any>"Closed",
}

export interface Tournament extends TournamentSummary {
    teams?: TournamentTeam[] | undefined;
    groups?: TournamentGroup[] | undefined;
    pairings?: TournamentPairing[] | undefined;
    mapTemplates?: string[] | undefined;
    winner?: TournamentTeam | undefined;
    phase: number;
}

export interface TournamentTeamSummary {
    id: string;
    name?: string | undefined;
    createdById?: string | undefined;
    groupOrder: number;
    state: TournamentTeamState;
}

export interface TournamentTeam extends TournamentTeamSummary {
    participants?: UserReference[] | undefined;
}

export enum TournamentTeamState {
    Open = <any>"Open",
    Active = <any>"Active",
    InActive = <any>"InActive",
}

export interface TournamentGroup {
    id: string;
    teams?: TournamentTeamSummary[] | undefined;
}

export interface TournamentPairing {
    teamA?: TournamentTeamSummary | undefined;
    teamB?: TournamentTeamSummary | undefined;
    teamAWon: number;
    teamBWon: number;
    numberOfGames: number;
    phase: number;
    order: number;
}

export class SwaggerException extends Error {
    message: string;
    status: number;
    response: string;
    result: any;

    constructor(message: string, status: number, response: string, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.result = result;
    }
}

function throwException(message: string, status: number, response: string, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, null);
}